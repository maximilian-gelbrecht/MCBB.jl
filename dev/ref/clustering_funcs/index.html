<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Clustering Functions · MCBB</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCBB</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../../introspective_features/">Introspective Features</a></li><li><a class="tocitem" href="../../hpc/">Running it on a HPC</a></li><li><a class="tocitem" href="../../multidim_parameters/">Multidimensional Parameter Setups</a></li><li><a class="tocitem" href="../../custom_problems/">Custom Problem</a></li><li><a class="tocitem" href="../../continuation/">Continuation</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../problem_types/">Problem Types</a></li><li><a class="tocitem" href="../parameter_var/">ParameterVar</a></li><li><a class="tocitem" href="../evaluation_funcs/">Evaluation Functions</a></li><li class="is-active"><a class="tocitem" href>Clustering Functions</a></li><li><a class="tocitem" href="../continuation/">Continuation</a></li><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../custom_problem/">Custom Problems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Clustering Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Clustering Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/master/docs/src/ref/clustering_funcs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Further-Evalution-and-Clustering-Functions-1"><a class="docs-heading-anchor" href="#Further-Evalution-and-Clustering-Functions-1">Further Evalution and Clustering Functions</a><a class="docs-heading-anchor-permalink" href="#Further-Evalution-and-Clustering-Functions-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MCBB.distance_matrix" href="#MCBB.distance_matrix"><code>MCBB.distance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> distance_matrix(sol::myMCSol, prob::myMCProblem, distance_func::Function, weights::AbstractArray; matrix_distance_func::Union{Function, Nothing}=nothing, histogram_distance_func::Union{Function, Nothing}=wasserstein_histogram_distance, relative_parameter::Bool=false, histograms::Bool=false, use_ecdf::Bool=true, k_bin::Number=1, bin_edges::AbstractArray)</code></pre><p>Calculate the distance matrix between all individual solutions.</p><p><strong>Histogram Method</strong></p><p>If it is called with the <code>histograms</code> flag <code>true</code>, computes for each run in the solution <code>sol</code> for each measure a histogram of the measures of all system dimensions. The binning of the histograms is computed with Freedman-Draconis rule and the same across all runs for each measure.</p><p>The distance matrix is then computed given a suitable histogram distance function <code>histogram_distance</code> between these histograms.</p><p>This is intended to be used in order to avoid symmetric configurations in larger systems to be distinguished from each other. Example: Given a system with 10 identical oscillators. Given this distance calculation a state where oscillator 1-5 are synchronized and 6-10 are not syncronized would be in the same cluster as a state where oscillator 6-10 are synchronized and 1-5 are not synchronized. If you don&#39;t want this kind of behaviour, use the regular <code>distance_matrix</code> function.</p><p><strong>Sparse and memory mapped options</strong></p><p>There are seperate routines for computing very large matrices, using either memory maped arrays (see <a href="#MCBB.distance_matrix_mmap"><code>distance_matrix_mmap</code></a>) or sparse arrays (see <a href="#MCBB.distance_matrix_sparse"><code>distance_matrix_sparse</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>sol</code>: solution</li><li><code>prob</code>: problem</li><li><code>distance_func</code>: The actual calculating the distance between the measures/parameters of each solution with each other. Signature should be <code>(measure_1::Union{Array,Number}, measure_2::Union{Array,Number}) -&gt; distance::Number. Example and default is</code>(x,y)-&gt;sum(abs.(x .- y))`.</li><li><code>weights</code>: Instead of the actual measure <code>weights[i_measure]*measure</code> is handed over to <code>distance_func</code>. Thus <code>weights</code> need to be <span>$N_{meas}+N_{par}$</span> long array.</li></ul><p><strong>Kwargs</strong></p><ul><li><code>relative_parameter</code>: If true, the paramater values during distance calcuation is rescaled to [0,1]</li><li><code>histograms::Bool</code>: If true, the distance calculation is based on <a href="ref/@ref"><code>distance_matrix_histogram</code></a> with the default histogram distance <a href="#MCBB.wasserstein_histogram_distance"><code>wasserstein_histogram_distance</code></a>.</li><li><code>histogram_distance_func</code>: The distance function between two histograms. Default is <a href="#MCBB.wasserstein_histogram_distance"><code>wasserstein_histogram_distance</code></a>.</li><li><code>matrix_distance_func</code>: The distance function between two matrices or arrays or length different from <span>$N_{dim}$</span>. Used e.g. for Crosscorrelation.</li><li><code>ecdf::Bool</code> if true the <code>histogram_distance</code> function gets the empirical cdfs instead of the histogram</li><li><code>k_bin::Int</code>: Multiplier to increase (<span>$k_{bin}&gt;1$</span>) or decrease the bin width and thus decrease or increase the number of bins. It is a multiplier to the Freedman-Draconis rule. Default: <span>$k_{bin}=1$</span></li><li><code>nbin_default::Int</code>: If the IQR is very small and thus the number of bins larger than <code>nbin_default</code>, the number of bins is set back to <code>nbin_default</code> and the edges and width adjusted accordingly.</li><li><code>nbin::Int</code> If specified, ingore all other histogram binning calculation and use nbin bins for the histograms.</li><li><code>bin_edges::AbstractArray</code>: If specified ignore all other histogram binning calculations and use this as the edges of the histogram (has to have one more element than bins, hence all edges). Needs to be an Array with as many elements as measures, if one wants automatic binning for one observables, this element of the array has to be <code>nothing</code>. E.g.: <code>[1:1:10, nothing, 2:0.5:5]</code>.</li></ul><p>Returns an instance of <a href="#MCBB.DistanceMatrix"><code>DistanceMatrix</code></a> or <a href="#MCBB.DistanceMatrixHist"><code>DistanceMatrixHist</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L126-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.distance_matrix_mmap" href="#MCBB.distance_matrix_mmap"><code>MCBB.distance_matrix_mmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distance_matrix_mmap(sol::myMCSol, prob::myMCProblem, distance_func::Function, weights::AbstractArray; matrix_distance_func::Union{Function, Nothing}=nothing, histogram_distance_func::Union{Function, Nothing}=wasserstein_histogram_distance, relative_parameter::Bool=false, histograms::Bool=false, use_ecdf::Bool=true, k_bin::Number=1, nbin_default::Int=50, el_type=Float32, save_name=&quot;mmap-distance-matrix.bin&quot;)</code></pre><p>Computes the distance matrix like <a href="#MCBB.distance_matrix"><code>distance_matrix</code></a> but uses memory-maped arrays. Use this if the distance matrix is too large for the memory of your computer. Same inputs as <a href="#MCBB.distance_matrix"><code>distance_matrix</code></a>, but with added <code>el_type</code> that determines the eltype of the saved matrix and <code>save_name</code> the name of the file on the hard disk.</p><p>Due to the restriction of memory-maped arrays saving and loading distance matrices computed like this with JLD2 will only work within a single machine. A way to reload these matrices / transfer them, is <a href="ref/@ref"><code>reload_mmap_distance_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L309-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.compute_distance" href="#MCBB.compute_distance"><code>MCBB.compute_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_distance(sol::myMCSol, i_meas::Int, distance_func::Function; use_histograms::Bool=false, use_ecdf::Bool=true, k_bin::Number=1, bin_edges::AbstractRange)</code></pre><p>Computes a (part of the) distance matrix for only a single measure <code>i_meas</code>. Follows otherwise the same logic as <a href="#MCBB.distance_matrix"><code>distance_matrix</code></a> but returns the matrix as an <code>Array{T,2}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.distance_matrix_sparse" href="#MCBB.distance_matrix_sparse"><code>MCBB.distance_matrix_sparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distance_matrix_sparse(sol::myMCSol, prob::myMCProblem, distance_func::Function, weights::AbstractArray; matrix_distance_func::Union{Function, Nothing}=nothing, histogram_distance_func::Union{Function, Nothing}=wasserstein_histogram_distance, relative_parameter::Bool=false, histograms::Bool=false, use_ecdf::Bool=true, k_bin::Number=1, nbin_default::Int=50, nbin::Union{Int, Nothing}=nothing, bin_edges::Union{AbstractArray, Nothing}=nothing, sparse_threshold::Number=Inf, el_type=Float32, check_inf_nan::Bool=true)</code></pre><p>Computes the distance matrix sparse. Same arguments as <a href="#MCBB.distance_matrix"><code>distance_matrix</code></a> with extra arguments</p><pre><code class="language-none">* `sparse_threshold`: Only distances smaller than this value are saved
* `check_inf_nan`: Only performs the Inf/NaN check if true.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L442-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.AbstractDistanceMatrix" href="#MCBB.AbstractDistanceMatrix"><code>MCBB.AbstractDistanceMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDistanceMatrix{T} &lt;: AbstractArray{T,2} end</code></pre><p>Abstract Datatype for all Distance Matrix types. Currently, there are within MCBB:     * <a href="#MCBB.DistanceMatrix"><code>DistanceMatrix</code></a>     * <a href="#MCBB.DistanceMatrixHist"><code>DistanceMatrixHist</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.DistanceMatrix" href="#MCBB.DistanceMatrix"><code>MCBB.DistanceMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistanceMatrix{T}</code></pre><p>Type for distance matrices. This type should behave just like any <code>AbstractArray{T,2}</code>. There&#39;s a <a href="ref/@ref"><code>convert</code></a> to <code>AbstractArray{T,2}</code>.</p><p>It also holds additional information about the distance calculation.</p><p><strong>Fields (and constructor)</strong></p><ul><li><code>data::AbstractArray{T,2}</code>: The actual distance matrix</li><li><code>weights::AbstractArray{T,1}</code>: The weights that were used to compute it</li><li><code>distance_func::Function</code>: The function that was used to compute it</li><li><code>relative_parameter::Bool</code>: Was the parameter rescaled?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L18-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.DistanceMatrixHist" href="#MCBB.DistanceMatrixHist"><code>MCBB.DistanceMatrixHist</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistanceMatrixHist{T}</code></pre><p>Type for distance matrices which were computed using Histograms. This type should behave just like any <code>AbstractArray{T,2}</code>. There&#39;s a <a href="ref/@ref"><code>convert</code></a> to <code>AbstractArray{T,2}</code>.</p><p>It also holds additional information about the distance calculation.</p><p><strong>Fields (and constructor)</strong></p><ul><li><code>data::AbstractArray{T,2}</code>: The actual distance matrix</li><li><code>weights::AbstractArray{T,1}</code>: The weights that were used to compute it</li><li><code>distance_func::Function</code>: The function that was used to compute the distance between the global measures</li><li><code>matrix_distance_func::Union{Function, Nothing}</code>: The function that was used to compute it</li><li><code>relative_parameter::Bool</code>: Was the parameter rescaled?</li><li><code>histogram_distance::Function</code>: Function used to compute the histogram distance</li><li><code>hist_edges</code>: Array of arrays/ranges with all histogram edges</li><li><code>bin_width</code>: Array of all histogram bin widths</li><li><code>ecdf</code>: Was the ECDF used in the distance computation?</li><li><code>k_bin</code>: Additional factor in bin_width computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L41-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.metadata!-Tuple{AbstractDistanceMatrix}" href="#MCBB.metadata!-Tuple{AbstractDistanceMatrix}"><code>MCBB.metadata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">metadata!(dm::AbstractDistanceMatrix, )</code></pre><p>Sets the input [<code>AbstractDistanceMatrix</code>] matrix itself empty, thus only containing metadata. This is usefull if the matrix itself is already saved otherwise (like with Mmap).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L433-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.wasserstein_histogram_distance" href="#MCBB.wasserstein_histogram_distance"><code>MCBB.wasserstein_histogram_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>One possible histogram distance for <code>distance_matrix_histogram</code> (also the default one). It calculates the 1-Wasserstein / Earth Movers Distance between the two ECDFs by first computing the ECDF and then computing the discrete integral</p><p><span>$\int_{-\infty}^{+\infty}|ECDF(hist\_1) - ECDF(hist\_2)| dx = \sum_i | ECDF(hist\_1)_i - ECDF(hist\_2)_i | \cdot bin\_width$</span>.</p><p>Returns a single (real) number. The input is the ecdf.</p><p>Adopted from <a href="ref/@ref"><code>https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wasserstein_distance.html</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L736-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.ecdf_hist" href="#MCBB.ecdf_hist"><code>MCBB.ecdf_hist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ecdf_hist(hist::Histogram)</code></pre><p>Returns the ECDF of a histogram (normalized) as an Array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L754-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_distance" href="#MCBB.cluster_distance"><code>MCBB.cluster_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster_distance(sol::myMCSol, D::AbstractDistanceMatrix, cluster_results::ClusteringResult,  cluster_1::Int, cluster_2::Int; measures::Union{AbstractArray, Nothing}=nothing, distance_func=nothing, histogram_distance=nothing, matrix_distance_func=nothing, k_bin::Number=1)</code></pre><p>Does calculate the distance between the members of two cluster seperatly for each measure</p><p><strong>Inputs</strong></p><ul><li><code>sol</code>: Solution object</li><li><code>D</code>: distance matrix from <a href="#MCBB.distance_matrix"><code>distance_matrix</code></a></li><li><code>cluster_results</code>: results from the clustering</li><li><code>cluster_1</code>: Index of the first cluster to be analysed (noise/outlier cluster = 1)</li><li><code>cluster_2</code>: Index of the second cluster to be analysed</li><li><code>measures</code>: Which measures should be analysed, default: all.</li></ul><p><strong>Output</strong></p><ul><li>Array with</li><li>Summary dictionary, mean and std of the distances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L668-L686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_means-Tuple{myMCSol,DbscanResult}" href="#MCBB.cluster_means-Tuple{myMCSol,DbscanResult}"><code>MCBB.cluster_means</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cluster_means(sol::myMCSol, clusters::ClusteringResult)</code></pre><p>Returns the mean of each measure for each cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L765-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_membership" href="#MCBB.cluster_membership"><code>MCBB.cluster_membership</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster_membership(par::AbstractArray, clusters::ClusteringResult)</code></pre><p>Calculates the proportion of members for each cluster for all parameter values.</p><p>Returns an instance <a href="#MCBB.ClusterMembershipResult"><code>ClusterMembershipResult</code></a> with fields:</p><ul><li><code>par</code>: the center value of the sliding windows, in case multiple parameter are being varied, it is a meshgrid.</li><li><code>data</code>: members of the clusters on the parameter grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1164-L1172">source</a></section><section><div><pre><code class="language-none">cluster_membership(prob::myMCProblem, clusters::ClusteringResult, window_size::AbstractArray, window_offset::AbstractArray; normalize::Bool=true, min_members::Int=0)
cluster_membership(prob::myMCProblem, clusters::ClusteringResult, window_size::Number, window_offset::Number; normalize::Bool=true,  min_members::Int=0)</code></pre><p>Calculates the proportion of members for each cluster within a parameter sliding window.</p><ul><li><code>prob</code>: problem</li><li><code>sol</code>: solution of <code>prob</code></li><li><code>clusters</code>: results from a DBSCAN run.</li><li><code>window_size</code>: Size of the window. In case multiple paramaters being varied has to be an array.</li><li><code>window_offset</code>: Offset of the sliding window. In case multiple paramaters being varied has to be an array.</li></ul><p>Returns an instance <a href="#MCBB.ClusterMembershipResult"><code>ClusterMembershipResult</code></a> with fields:</p><ul><li><code>par</code>: the center value of the sliding windows, in case multiple parameter are being varied, it is a meshgrid.</li><li><code>data</code>: members of the clusters on the parameter grid</li></ul><p>The results can be plotted with directly with <code>plot(results, kwargs...)</code>. See <a href="#MCBB.ClusterMembershipResult"><code>ClusterMembershipResult</code></a> for details on the plotting and operationg on this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1188-L1205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.ClusterMembershipResult" href="#MCBB.ClusterMembershipResult"><code>MCBB.ClusterMembershipResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterMembershipResult{T,S}</code></pre><p>Stores the results of <a href="#MCBB.cluster_membership"><code>cluster_membership</code></a> and can be used for <a href="ref/@ref"><code>ClusterMembershipPlot</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>par</code>: Parameter Array or Mesh</li><li><code>data</code>: Cluster Membership data on <code>par</code>-Parameter grid.</li><li><code>multidim_flag</code>: Is the experiment multidimensional?</li></ul><p><strong>Plot</strong></p><pre><code class="language-none">plot(cm::ClusterMembershipResult, kwargs...)</code></pre><p>Does plot the <a href="#MCBB.ClusterMembershipResult"><code>ClusterMembershipResult</code></a>. Uses Plot recipes and thus hands over all kwargs possible from Plots.jl.</p><p><strong>Hints</strong></p><p>The order of the labels for the legend is reversed.</p><p><strong>Additional Kwargs</strong></p><ul><li><code>plot_index</code>: Range or Array with the indices of the clusters to be plotted. Default: all.</li></ul><p><strong>Additonal operation defined</strong></p><pre><code class="language-none">* can be indexed
* can be sorted, [`Base.sort!(cm::ClusterMembershipResult; ignore_first::Bool)`](@ref)
* can be summed, [`Base.sum(cm::ClusterMembershipResult, indices::AbstractArray{Int,1})`](@ref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1267-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort!-Tuple{ClusterMembershipResult}" href="#Base.sort!-Tuple{ClusterMembershipResult}"><code>Base.sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort!(cm::ClusterMembershipResult; ignore_first::Bool=false)</code></pre><p>Sorts <code>cm</code> inplace by the count of members of the clusters from low to high. If <code>ignore_first</code> is true, the first cluster (with DBSCAN this is the outlier cluster) is ignored while sorting and remains the first cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1307-L1311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{ClusterMembershipResult,AbstractArray{Int64,1}}" href="#Base.sum-Tuple{ClusterMembershipResult,AbstractArray{Int64,1}}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.sum(cm::ClusterMembershipResult, indices::AbstractArray{Int,1})</code></pre><p>Returns a <code>ClusterMembershipResult</code> with all <code>indices</code> clusters summed together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1328-L1332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.get_trajectory" href="#MCBB.get_trajectory"><code>MCBB.get_trajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_trajectory(prob::MCBBProblem, sol::MCBBSol, clusters::ClusteringResult, i::Int; only_sol::Bool=true)</code></pre><p>Solves and returns a trajectory that is classified in cluster <code>i</code>. Randomly selects one IC/Parameter configuration, so that mulitple executions of this routine will yield different results! If <code>only_sol==true</code> it returns only the solution, otherwise it returns a tuple <code>(solution, problem, i_run)</code> where <code>i_run</code> is the number of the trial in <code>prob</code> and <code>sol</code>.</p><pre><code class="language-none">get_trajectory(prob::MCBBProblem, sol::MCBBSol, i::Int, only_sol::Bool=true)</code></pre><p>Solves problem <code>i</code> and returns a trajectory. If <code>only_sol==true</code> it returns only the solution, otherwise it returns a tuple <code>(solution, problem, i_run)</code> where <code>i_run</code> is the number of the trial in <code>prob</code> and <code>sol</code>.</p><p><strong>Example</strong></p><p>Plot with e.g</p><pre><code class="language-none">using PyPlot
IM = imshow(Matrix(get_trajectory(prob,sol,db_res,1)), aspect=2)
ylabel(&quot;System Dimension i&quot;)
xlabel(&quot;Time t&quot;)
cb = colorbar(IM, orientation=&quot;horizontal&quot;)
cb[:ax][:set_xlabel](&quot;Colorbar: Im(z)&quot;, rotation=0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1459-L1478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_measure_mean" href="#MCBB.cluster_measure_mean"><code>MCBB.cluster_measure_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster_measure_mean(sol::myMCSol, clusters:ClusteringResult, i::Int)</code></pre><p>Return the Mean of measure <code>i</code> for each cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L789-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_measure_std" href="#MCBB.cluster_measure_std"><code>MCBB.cluster_measure_std</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster_measure_std(sol::myMCSol, clusters:ClusteringResult, i::Int)</code></pre><p>Return the std of measure <code>i</code> for each cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L804-L808">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_measures" href="#MCBB.cluster_measures"><code>MCBB.cluster_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> cluster_measures(prob::myMCProblem, sol::myMCSol, clusters::ClusteringResult, window_size::AbstractArray, window_offset::AbstractArray)
 cluster_measures(prob::myMCProblem, sol::myMCSol, clusters::ClusteringResult, window_size::Number, window_offset::Number)</code></pre><p>Calculated the measures for each cluster along a sliding window. Can also handle multiple parameters being varied.</p><ul><li><code>prob</code>: problem</li><li><code>sol</code>: solution of <code>prob</code></li><li><code>clusters</code>: results from a DBSCAN run.</li><li><code>window_size</code>: Size of the window. In case multiple paramaters being varied has to be an array.</li><li><code>window_offset</code>: Offset of the sliding window. In case multiple paramaters being varied has to be an array.</li></ul><p>Returns an instance of <a href="#MCBB.ClusterMeasureResult"><code>ClusterMeasureResult</code></a> with fields:</p><ul><li><code>par</code>: the center value of the sliding windows, in case multiple parameter are being varied, it is a meshgrid.</li><li><code>cluster_measures</code>: (per dimension) measures on the parameter grid</li><li><code>cluster_measures_global</code>: global measures on the parameter grid</li></ul><p><strong>Plot:</strong></p><ul><li><p>The <code>i</code>-th measure can be plotted with <code>plot(res::ClusterMeasureResult, i::Int, kwargs...)</code></p></li><li><p>A single cluster and measure can be plotted with <code>plot(res::ClusterMeasureResult, i_meas::Int, i_cluster::Int, kwargs...)</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L860-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.ClusterMeasureResult" href="#MCBB.ClusterMeasureResult"><code>MCBB.ClusterMeasureResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterMeasureResult</code></pre><p>Results of <a href="#MCBB.cluster_measures"><code>cluster_measures</code></a>.</p><p><strong>Fields:</strong></p><ul><li><code>par</code></li><li><code>cluster_measures</code></li><li><code>cluster_measures_global</code></li></ul><p><strong>Plot:</strong></p><p>The <code>i</code>-th measure of the <code>j-</code>th cluster can be plotted with <code>plot(res::ClusterMeasureResult, i::Int, j::Int, kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L908-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_measures_sliding_histograms" href="#MCBB.cluster_measures_sliding_histograms"><code>MCBB.cluster_measures_sliding_histograms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster_measures_sliding_histograms(prob::myMCProblem, sol::myMCSol, clusters::ClusteringResult, i_meas::Int, window_size::Number, window_offset::Number; kwargs...)</code></pre><p>Calculates for each window in the sliding window array a histogram of all results of meausure <code>i_meas</code> of all runs seperatly for each cluster.</p><p>Input:</p><ul><li><code>prob::myMCProblem</code>: problem</li><li><code>sol::myMCSol</code>: solution object</li><li><code>clusters::ClusteringResult</code>: cluster results</li><li><code>i_meas::Int</code>: index of the measure to be analyzed</li><li><code>window_size::AbstractArray</code>: size of the window, number or Array with length according to the number of parameters</li><li><code>window_offset::AbstractArray</code>: size of the window, number or Array with length according to the number of parameters</li></ul><p>Keyword arguments</p><ul><li><code>k_bin::Number</code>: Bin Count Modifier. <code>k_bin</code>-times the Freedman Draconis rule is used for binning the data. Default: 1</li><li><code>normalization_mode::Symbol</code>, normalization mode applied to Histograms. Directly handed over to <a href="../custom_problem/#LinearAlgebra.normalize-Tuple{CustomMCBBSolution,AbstractArray}"><code>normalize</code></a>.</li><li><code>nbin::Int</code>: Uses nbins for the histograms instead of the (automatic) Freedman Draconis rule</li><li><code>bin_edges::AbstractRange</code>: Uses these edges for the histograms.</li><li><code>state_filter::AbstractArray</code>: Only use these system dimension as the basis for the computation, default: all. Attention: if the evalation function already used a state_filter this will be refering only to the system dimension that were measured.</li></ul><p>Returns an instance of <a href="#MCBB.ClusterMeasureHistogramResult"><code>ClusterMeasureHistogramResult</code></a> with fields:</p><ul><li><code>hist_vals</code>: N<em>cluster, N</em>windows..., N_bins - sized array with the value of the histograms for each window</li><li><code>par</code>: midpoint of the sliding windows, &quot;x-axis-labels&quot; of the plot</li><li><code>hist_bins</code>: center of the bins, &quot;y-axis-label&quot; of the plot</li></ul><p>Can be plotted with <code>plot(res::ClusterMeasureHistogramResult, kwargs...)</code>. See <a href="#MCBB.ClusterMeasureHistogramResult"><code>ClusterMeasureHistogramResult</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L930-L957">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.ClusterMeasureHistogramResult" href="#MCBB.ClusterMeasureHistogramResult"><code>MCBB.ClusterMeasureHistogramResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterMeasureHistogramResult</code></pre><p>Stores results of <a href="#MCBB.cluster_measures_sliding_histograms"><code>cluster_measures_sliding_histograms</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>hist_vals</code>: N<em>cluster, N</em>windows..., N_bins - sized array with the value of the histograms for each window</li><li><code>par</code>: midpoint of the sliding windows, &quot;x-axis-labels&quot; of the plot</li><li><code>hist_edges</code>: center of the bins, &quot;y-axis-label&quot; of the plot</li><li><code>multidim_flag</code></li></ul><p><strong>Plot</strong></p><p>Can be plotted with <code>plot(res::ClusterMeasureHistogramResult, i, kwargs...)</code>. With <code>i</code> being the number of the cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1010-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.ClusterICSpaces" href="#MCBB.ClusterICSpaces"><code>MCBB.ClusterICSpaces</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterICSpaces</code></pre><p>This function/struct returns the distributions as histograms of ICs (and Parameter) in each dimension for cluster seperatly, it also returns the data itself, means and stds. If additional keyword arguments min<em>par, max</em>par are given, it limits the analysis to the specified parameter range.</p><p>Fields of the struct:</p><ul><li><code>data</code>: array of array of arrays, the ICs and pars for each cluster and dimension</li><li><code>histograms</code>: N<em>cluster x N</em>dim Array of Histograms of ICs/Par</li><li><code>means</code>: Means of each dimension for each cluster</li><li><code>stds</code>: Stds of each dimension for each cluster</li><li><code>cross_dim_means</code>: list of Means of ICs across IC-dimensions per Cluster</li><li><code>cross_dim_stds</code>: list of Std of ICs across IC-dimensions per Cluster</li><li><code>cross_dim_kurts</code>: list of Kurtosis of ICs across IC-dimensions per Cluster</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">ClusterICSpaces(prob::myMCProblem, sol::myMCSol, clusters::ClusteringResult; min_par::Number=-Inf, max_par::Number=Inf, nbins::Int64=20)</code></pre><ul><li><code>prob</code>: Problem</li><li><code>sol</code>: solution of <code>prob</code></li><li><code>clusters</code>: DBSCAN results</li><li><code>min_par</code>, <code>max_par</code>: restrict the analysis to parameters within this value range</li><li><code>nbins</code>: Number of bins of the histograms</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1036-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.cluster_n_noise" href="#MCBB.cluster_n_noise"><code>MCBB.cluster_n_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cluster_n_noise(clusters::ClusteringResult)</code></pre><p>Returns the number of points assignt to the &quot;noise&quot; cluster (somehow this is not automaticlly returned by the routine of Clustering.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1149-L1153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.measure_on_parameter_sliding_window" href="#MCBB.measure_on_parameter_sliding_window"><code>MCBB.measure_on_parameter_sliding_window</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_on_parameter_sliding_window</code></pre><p>Does calculate measures (per cluster) on parameter sliding windows. This routine is called by <code>cluster_membership</code> and <code>cluster_measures</code> but can also be used for plotting measures on the parameter grid manually.</p><p><em>ATTENTION</em>: If a cluster has no members within a window the value is set to <code>NaN</code>. This should simply omit these points from beeing plotted (while <code>missing</code> and <code>nothing</code> are currently not compatible with most plotting packages).</p><pre><code class="language-none">measure_on_parameter_sliding_window(prob::myMCProblem, sol::myMCSol, i::Int, clusters::ClusteringResult, window_size::Number, window_offset::Number)</code></pre><p>Does return the <code>i</code>-th measure for each cluster seperatly on the parameter sliding window grid</p><ul><li><p><code>prob</code>: Problem</p></li><li><p><code>sol</code>: solution of <code>prob</code></p></li><li><p><code>i</code>: function returns the <code>i</code>-th measure</p></li><li><p><code>clusters</code>: results from a DBSCAN run.</p></li><li><p><code>window_size</code>: Size of the window. In case multiple paramaters being varied has to be an array.</p></li><li><p><code>window_offset</code>: Offset of the sliding window. In case multiple paramaters being varied has to be an array.</p><p>measure<em>on</em>parameter<em>sliding</em>window(prob::myMCProblem, sol::myMCSol, i::Int, window<em>size::Number, window</em>offset::Number)</p></li></ul><p>Does return the <code>i</code>-th measure on the parameter sliding window grid (does <em>not</em> calculate the measure for each cluster seperatly)</p><p>All methods return a tuple with:</p><ul><li><code>parameter_windows</code>: the center value of the sliding windows, in case multiple parameter are being varied, it is a meshgrid.</li><li><code>cluster_measures</code>: members of the clusters on the parameter grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1342-L1367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.k_dist" href="#MCBB.k_dist"><code>MCBB.k_dist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> k_dist(D::AbstractArray, k::Int=4)</code></pre><p>Helper function for estimating a espilon value for DBSCAN. In the original paper, Ester et al. suggest to plot the <code>k</code>-dist graph (espacially for <span>$k=4$</span>) to estimate a value for <code>eps</code> given <span>$minPts = k$</span>. It computes the distance to the <code>k</code>-th nearast neighbour for all data points given their distance matrix.</p><ul><li><code>D</code>: Distance matrix</li><li><code>k</code>: calculate the distance to the <code>k</code>-th neighbour</li></ul><p>Returns sorted array with the k-dist of all elements of <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1494-L1503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.KNN_dist" href="#MCBB.KNN_dist"><code>MCBB.KNN_dist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">KNN_dist(D::AbstractArray, K::Int)</code></pre><p>Returns the cumulative <code>K-</code>th nearest neighbour distance.</p><ul><li><code>D</code>: Distance matrix</li><li><code>K</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1532-L1539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCBB.KNN_dist_relative" href="#MCBB.KNN_dist_relative"><code>MCBB.KNN_dist_relative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">KNN_dist_relative(D::AbstractArray, rel_K::Float64=0.005)</code></pre><p>Returns the cumulative distance to the <code>rel_K*N</code> nearest neighbour.</p><ul><li><code>D</code>: Distance matrix</li><li><code>rel_K</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/c03832d07af704704306dee00d572172e438207b/src/eval_clustering.jl#L1518-L1525">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>load_D</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>load_D_hist</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../evaluation_funcs/">« Evaluation Functions</a><a class="docs-footer-nextpage" href="../continuation/">Continuation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 11 October 2020 19:52">Sunday 11 October 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
