<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evaluation Functions · MCBB</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MCBB</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../basic_usage/">Basic Usage</a></li><li><a class="toctext" href="../../introspective_features/">Introspective Features</a></li><li><a class="toctext" href="../../hpc/">Running it on a HPC</a></li><li><a class="toctext" href="../../multidim_parameters/">Multidimensional Parameter Setups</a></li><li><a class="toctext" href="../../custom_problems/">Custom Problem</a></li><li><a class="toctext" href="../../continuation/">Continuation</a></li></ul></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../problem_types/">Problem Types</a></li><li><a class="toctext" href="../parameter_var/">ParameterVar</a></li><li class="current"><a class="toctext" href>Evaluation Functions</a><ul class="internal"></ul></li><li><a class="toctext" href="../clustering_funcs/">Clustering Functions</a></li><li><a class="toctext" href="../continuation/">Continuation</a></li><li><a class="toctext" href="../systems/">Systems</a></li><li><a class="toctext" href="../custom_problem/">Custom Problems</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Evaluation Functions</a></li></ul><a class="edit-page" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/master/docs/src/ref/evaluation_funcs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Evaluation Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Evaluation-Functions-1" href="#Evaluation-Functions-1">Evaluation Functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.eval_ode_run" href="#MCBB.eval_ode_run"><code>MCBB.eval_ode_run</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_ode_run</code></pre><p>Evaluation functions for the <code>EnsembleProblem</code>. Given a set of measures the solution <code>sol</code> is evaluated seperatly per dimension. An additional set of global measures take in the complete solution and return a single number or a matrix. Handing over this function to <code>DEMCBBProblem</code> (and thus also to <code>EnsembleProblem</code>) the expected signature is <code>(sol, i::Int) -&gt; (results, repeat::Bool)</code>. Here, there are several more general versions that can be adjusted to the experiment.</p><pre><code class="language-none">eval_ode_run(sol, i, state_filter::Array{Int64,1}, eval_funcs::Array{&lt;:Function,1}, matrix_eval_funcs::Union{AbstractArray, Nothing}=nothing, global_eval_funcs::Union{AbstractArray, Nothing}=nothing; failure_handling::Symbol=:None, cyclic_setback::Bool=false, replace_inf=nothing)</code></pre><ul><li><code>sol</code>: solution of one of the EnsembleProblem runs, should have only timesteps with constant time intervals between them</li><li><code>i</code>: Int, number of iteration/run</li><li><code>state_filter</code>: Array with indicies of all dimensions (of the solutions) that should be evaluated</li><li><code>eval_funcs</code>: Array of functions that should be applied to every dimension of the solution. Signature: <code>(sol::AbstractArray) -&gt; measure</code> or <code>(sol::AbstractArray, previous_results::AbstractArray) -&gt; measure</code> depending on the value of <code>flag_past_measures</code>.</li><li><code>matrix_eval_funcs</code>: Array of functions that should be applied to the complete N<em>dimensional solution and return a matrix (or vector), like e.g covariance or correlation, signature <code>(N-Dim Array w/ Samples ::AbstractArray) -&gt; Measure::AbstractArray</code> (technical detail: length(measure)!=N</em>dim (system dimension))</li><li><code>global_eval_funcs</code>: Array of functions that should be applied to the complete N-dimensional solution, signature (N-Dim Array w/ Samples ::AbstractArray) -&gt; Measure::Number</li><li><code>failure_handling</code>: How failure of integration is handled. Should be <code>:None</code> (do no checks), <code>:Inf</code> (If <code>retcode==:DtLessThanMin: return Inf</code>) or <code>:Repeat</code> (If no succes, repeat the trial (only works with random initial conditions))</li><li><code>cyclic_setback</code>: Bool, if true <span>$N*2\pi$</span> is substracted from the solution so that the first element of the solution that is analysed is within <span>$[-\pi, \pi]$</span>. Usefull e.g. for phase oscillators.</li><li><code>replace_inf</code>: Number or Nothing, if a number replaces all Infs in the solution with this number. Can be usefull if one still wants to distinguish between different solutions containing Infs, +Inf is replaced by the Number, -Inf by (-1)*Number.</li><li><code>flag_past_measures::Bool</code>: If true als function within <code>eval_funcs</code> also receive the previous results (of the other measures for the same dimension) as an extra arguments. Thus all functions need to have a signature <code>(sol::AbstractArray, previous_results::AbstractArray) -&gt; measure</code>. If false the functions only receive the solution vector, thus the function should have the signature <code>(sol::AbstractArray) -&gt; measure</code></li></ul><p><strong>Example function</strong></p><p>In order to derive a valid evaluation function from this for the <code>MCBBProblem</code> one can define a function similar to this:</p><pre><code class="language-none">function my_eval_ode_run(sol, i)
    N_dim = length(sol.prob.u0)
    state_filter = collect(1:N_dim)
    eval_funcs = [mean, std]
    eval_ode_run(sol, i, state_filter, eval_funcs)
end</code></pre><p><strong>Utilizing previous results</strong></p><p>If one wants to utilze the previous results (and don&#39;t compute measures twice), one has to use the <code>flag_past_measures=true</code> option. This is only possible for the per dimension measures. An example could read:</p><pre><code class="language-none">function my_eval_ode_run(sol, i)
    N_dim = length(sol.prob.u0)
    state_filter = collect(1:N_dim)
    meanval(u::AbstractArray, past_measures::AbstractArray) = StatsBase.mean(u)
    standarddev(u::AbstractArray, past_measures::AbstractArray) = StatsBase.std(u; mean=dim_measures[1], corrected=false)
    eval_funcs = [meanval, standarddev, empirical_1D_KL_divergence_hist]
    eval_ode_run(sol, i, state_filter, eval_funcs; flag_past_measures=true)
end</code></pre><p>Latter function is also already available as a default <code>eval_ode_run</code> in this library. The order of the functions is important. In this example <code>meanval</code> will always get an empty array as the second argument, <code>standarddev</code> will get an array with the result from <code>meanval</code> as the only value and <code>empirical_1D_KL_divergence_hist</code> will get an additional array with the results from <code>meanval</code> and <code>standarddev</code>.</p><pre><code class="language-none">eval_ode_run(sol, i)</code></pre><p>Default <code>eval_ode_run</code>, identical to the code above.</p><p><strong>Continue Integration / Response Analysis</strong></p><pre><code class="language-none"> eval_ode_run(sol, i, state_filter::Array{Int64,1}, eval_funcs::Array{&lt;:Function,1},  matrix_eval_funcs::Union{AbstractArray, Nothing}, global_eval_funcs::Union{AbstractArray, Nothing}, par_var::OneDimParameterVar, eps::Float64, par_bounds::AbstractArray, distance_matrix_func; failure_handling::Symbol=:None, cyclic_setback::Bool=false, flag_past_measures::Bool=false, N_t::Int=200, alg=nothing, debug::Bool=false, return_pm::Bool, new_tspan::Union{Nothing, AbstractArray}, kwargs...)</code></pre><p>Evaluation function that continues each integration and computes the same measures for <code>par+eps</code> and <code>par-eps</code>. Returns the results of the usual <code>eval_ode_run</code> (all measures) and additionally the response of the distance function to the paramater increase/decrease.</p><ul><li><p><code>par_var</code>: <code>ParameterVar</code> struct, same as handed over to the problem type.</p></li><li><p><code>eps</code>: Number, response at par+/-eps</p></li><li><p><code>distance_matrix_func</code>: Same distance matrix functions that will also be used for the later analysis/clustering, expected signature: <code>(sol::MCBBSol, prob::MCBBProblem) -&gt; D::AbstractArray</code>, . Attension: if the weight vector is provided this version of the distance it needs to have one less element as the function later used before clustering because the result of the response analysis is an additional measure.</p></li><li><p><code>N_t</code>: Time steps for the continued integration</p></li><li><p><code>alg</code>: Algorithm for <code>solve()</code></p></li><li><p><code>debug</code>: If true, also returns the DifferentialEquations problem solved for the continuation.</p></li><li><p><code>return_pm</code>: If true, returns <code>D(p+dp)</code> AND <code>D(p-dp)</code>. If false returns the mean of these.</p></li><li><p><code>new_tspan</code>: timespan for continued integeration, default: 15% of the original timespan</p></li><li><p>all further keyword arguments will be handed over to <code>solve(prob::DEMCBBProblem, ...)</code></p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L9-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.empirical_1D_KL_divergence_hist" href="#MCBB.empirical_1D_KL_divergence_hist"><code>MCBB.empirical_1D_KL_divergence_hist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">empirical_1D_KL_divergence_hist(u::AbstractArray, mu::Number, sig::Number, hist_bins::Int=31, n_stds::Number=3, sig_tol=1e-4::Number)</code></pre><p>One measure that can be used with <code>eval_ode_run</code>. Computes the empirical Kullback-Leibler Divergence of the input to a normal distribution with the same mean and std as the input, thus it is a measure of normality. This version does this with histograms.</p><ul><li><code>u</code>: Input Array</li><li><code>mu</code>: Mean of <code>u</code></li><li><code>sig</code>: Std of <code>u</code></li><li><code>hist_bins</code>: number of bins of the histogram to estimate the empirical pdf of the data</li><li><code>n_stds</code>: Interval that the histogram covers in numbers of stds (it covers  mean +/- n_stds*std)</li><li><code>sig_tol</code>: At times, all KL div methods run into difficulties when <code>sig</code> gets really small, for <code>sig&lt;sig_tol</code> 0 is returned as a result because in the limit of <code>sig</code> -&gt; 0 the reference distribution is a delta distribution and the data is constant thus also a delta distribution. hence the distributions are identical and the KL div should be zero.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L292-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.empirical_1D_KL_divergence_pc" href="#MCBB.empirical_1D_KL_divergence_pc"><code>MCBB.empirical_1D_KL_divergence_pc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">empirical_1D_KL_divergence_pc(u::AbstractArray, mu::Number, sig::Number)</code></pre><p>One measure that can be used with <code>eval_ode_run</code>. Computes the empirical Kullback-Leibler Divergence of the input to a normal distribution with the same mean and std as the input, thus it is a measure of normality. This version does this based on a linearly interpolated emperical CDF, see Perez-Cruz (IEEE, 2008). This version can run into numerical difficulties for discrete systems with alternating inputs like [a,-a,a,a] and large 2a. For reasonable continous input it is a better and parameter free approximation to the KL divergence than the histogram estimator.</p><ul><li><code>u</code>: Input Array</li><li><code>mu</code>: Mean of <code>u</code></li><li><code>sig</code>: Std of <code>u</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L333-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.wasserstein_ecdf" href="#MCBB.wasserstein_ecdf"><code>MCBB.wasserstein_ecdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wasserstein_ecdf(u::AbstractArray, mu::Number, sig::Number)</code></pre><p>One measure that can be used with <code>eval_ode_run</code>. Computes the 1-wasserstein distance based on ECDFs.</p><ul><li><code>u</code>: Input Array</li><li><code>mu</code>: Mean of <code>u</code></li><li><code>sig</code>: Std of <code>u</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L429-L437">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.correlation" href="#MCBB.correlation"><code>MCBB.correlation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">correlation(sol::AbstractArray)</code></pre><p>Example function for <code>matrix_eval_funcs</code>. This routine calculates the absolute value of the Pearson correlation between the time series of all system dimensions and returns it as a matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L458-L462">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.correlation_hist" href="#MCBB.correlation_hist"><code>MCBB.correlation_hist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">correlation_hist(sol::AbstractArray, nbins::Int=30)</code></pre><p>Example function for <code>matrix_eval_funcs</code>. This routine calculates the absolute value of the Pearson correlation between the time series of all system dimensions and returns the weights of histogram fitted to all of these values. It uses the same binning for all calculations with the edges calculated by <code>0:1. /nbins:1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L465-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.correlation_ecdf" href="#MCBB.correlation_ecdf"><code>MCBB.correlation_ecdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>correlation_ecdf(sol::AbstractArray, nbins::Int=30)</p><p>Example function for <code>matrix_eval_funcs</code>. This routine calculates the absolute value of the Pearson correlation between the time series of all system dimensions and the ECDF of a histogram fitted to all of these values. It uses the same binning for all calculations with the edges calculated by <code>0:1. /nbins:1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L477-L481">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCBB.check_inf_nan" href="#MCBB.check_inf_nan"><code>MCBB.check_inf_nan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">check_inf_nan(sol::myMCSol)</code></pre><p>Checks if any of the results is <code>inf</code> or <code>nan</code> and returns the indices in a dictionary with keys <code>Inf</code> and <code>NaN</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/5d7a6f539b39c5f6c5aa078bf9ad6e75077cc7ed/src/eval_mc_prob.jl#L253-L257">source</a></section><footer><hr/><a class="previous" href="../parameter_var/"><span class="direction">Previous</span><span class="title">ParameterVar</span></a><a class="next" href="../clustering_funcs/"><span class="direction">Next</span><span class="title">Clustering Functions</span></a></footer></article></body></html>
