<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introspective Features · MCBB</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCBB</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basic_usage/">Basic Usage</a></li><li class="is-active"><a class="tocitem" href>Introspective Features</a><ul class="internal"><li><a class="tocitem" href="#Cluster-Membership-1"><span>Cluster Membership</span></a></li><li><a class="tocitem" href="#Plot-Measures-1"><span>Plot Measures</span></a></li><li><a class="tocitem" href="#Cluster-Measures-1"><span>Cluster Measures</span></a></li><li><a class="tocitem" href="#Single-Trajectories-1"><span>Single Trajectories</span></a></li><li><a class="tocitem" href="#Cluster-Measure-Histograms-1"><span>Cluster Measure Histograms</span></a></li><li><a class="tocitem" href="#Cluster-Initial-Conditions-1"><span>Cluster Initial Conditions</span></a></li></ul></li><li><a class="tocitem" href="../hpc/">Running it on a HPC</a></li><li><a class="tocitem" href="../multidim_parameters/">Multidimensional Parameter Setups</a></li><li><a class="tocitem" href="../custom_problems/">Custom Problem</a></li><li><a class="tocitem" href="../continuation/">Continuation</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../ref/problem_types/">Problem Types</a></li><li><a class="tocitem" href="../ref/parameter_var/">ParameterVar</a></li><li><a class="tocitem" href="../ref/evaluation_funcs/">Evaluation Functions</a></li><li><a class="tocitem" href="../ref/clustering_funcs/">Clustering Functions</a></li><li><a class="tocitem" href="../ref/continuation/">Continuation</a></li><li><a class="tocitem" href="../ref/systems/">Systems</a></li><li><a class="tocitem" href="../ref/custom_problem/">Custom Problems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Introspective Features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introspective Features</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maximilian-gelbrecht/MCBB.jl/blob/master/docs/src/introspective_features.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introspective-Features-1"><a class="docs-heading-anchor" href="#Introspective-Features-1">Introspective Features</a><a class="docs-heading-anchor-permalink" href="#Introspective-Features-1" title="Permalink"></a></h1><p>This page showcases introspective features of the libary.</p><p>The example are First Order Kuramoto Oscillators with <span>$\mathcal{N}(0.5,0.1)$</span> distributed eigenfrequencies on a Erdos Renyi random network. Subsequently the coupling is increased as the free parameter. The basic setup is identical to the previous section.</p><pre><code class="language-julia">using MCBB
using LightGraphs
using Clustering
using DifferentialEquations
using Distributions
using StatsBase
using Plots
using Random
import PyPlot
Random.Random.seed!(13423);</code></pre><pre><code class="language-julia">N = 20
K = 0.5
nd = Normal(0.5, 0.1)
w_i_par = rand(nd,N) # eigenfrequencies

net = erdos_renyi(N, 0.2)
A = adjacency_matrix(net)

ic = zeros(N)
ic_dist = Uniform(-pi,pi)
kdist = Uniform(0,5)
ic_ranges = ()-&gt;rand(ic_dist)
N_ics = 5000
K_range = ()-&gt;rand(kdist)
pars = kuramoto_network_parameters(K, w_i_par, N, A)

rp = ODEProblem(kuramoto_network, ic, (0.,1000.), pars)

# we also calculate the order parameter, we won&#39;t use it for clustering, but we&#39;ll use it as a check
function k_order_parameter(u::AbstractArray)
    uend = u[:,end]
    N = length(uend)
    1. /N*sqrt((sum(sin.(uend)))^2+(sum(cos.(uend)))^2)
end

function eval_ode_run_kura(sol, i)
    N_dim = length(sol.prob.u0)
    state_filter = collect(1:N_dim)
    eval_funcs = [mean, std]
    matrix_eval_funcs = []
    global_eval_funcs = [k_order_parameter]
    eval_ode_run(sol, i, state_filter, eval_funcs, matrix_eval_funcs, global_eval_funcs, cyclic_setback=true)
end

tail_frac = 0.9 #
ko_mcp = DEMCBBProblem(rp, ic_ranges, N_ics, pars, (:K, K_range), eval_ode_run_kura, tail_frac)
kosol = solve(ko_mcp)</code></pre><p>The results are sorted by parameter value, <a href="../ref/problem_types/#MCBB.show_results"><code>show_results</code></a> shows only results within the given parameter range.</p><p><a href="../ref/custom_problem/#LinearAlgebra.normalize-Tuple{CustomMCBBSolution,AbstractArray}"><code>normalize(sol:DEMCBBSol)</code></a> normalized the results so that all measures are within the range <span>$[0,1]$</span>.</p><h2 id="Cluster-Membership-1"><a class="docs-heading-anchor" href="#Cluster-Membership-1">Cluster Membership</a><a class="docs-heading-anchor-permalink" href="#Cluster-Membership-1" title="Permalink"></a></h2><pre><code class="language-julia">D_k = distance_matrix(kosol, ko_mcp, [1.,0.5,0,1.], histograms=true, k_bin=2); # no weight on the order_parameter db_eps = 110 # we found that value by scanning manually
db_eps = 1.15# we found that value by scanning manually
db_res = dbscan(D_k,db_eps,20)
cluster_members = cluster_membership(ko_mcp,db_res,0.1,0.025);
plot(cluster_members)</code></pre><p><img src="../img/output_4_0.png" alt="Kuramato Membership Diagram"/></p><h2 id="Plot-Measures-1"><a class="docs-heading-anchor" href="#Plot-Measures-1">Plot Measures</a><a class="docs-heading-anchor-permalink" href="#Plot-Measures-1" title="Permalink"></a></h2><ul><li>plot one of the measures dependend on the parameter with <a href="../ref/problem_types/#MCBB.get_measure"><code>get_measure</code></a> gets the <span>$k$</span>-th measure. In this case the order is [mean, std, kl-div, order parameter]</li><li>get the parameter array with <code>parameter(prob::BifMCProblem)</code></li><li>here we plot the Order Parameter</li></ul><pre><code class="language-julia">plot(parameter(ko_mcp),get_measure(kosol,3), xlabel=&quot;Coupling K&quot;, ylabel=&quot;Order Parameter R&quot;)</code></pre><p><img src="../img/output_6_0.png" alt="Kuramaoto Order Parameter"/></p><p>Or do this with a sliding window:</p><pre><code class="language-julia">p_wins, R_grid = measure_on_parameter_sliding_window(ko_mcp, kosol, 3, 0.2, 0.025);
plot(p_wins,R_grid[1,1,:], xlabel=&quot;Coupling K&quot;, ylabel=&quot;Order Parameter R&quot;,title=&quot;Slding Window Order Parameter&quot;)</code></pre><p><img src="../img/output_7_0.png" alt="Kuramoto Order Parameter Sliding Window"/></p><p>Of course we can also get the multidimensional measures</p><pre><code class="language-julia">plot(parameter(ko_mcp),get_measure(kosol,1), xlabel=&quot;Coupling K&quot;, ylabel=&quot;Mean&quot;)</code></pre><p><img src="../img/output_8_0.png" alt="Kuramoto Mean"/></p><p>In this plot we already see the onset of the synchronization.</p><h2 id="Cluster-Measures-1"><a class="docs-heading-anchor" href="#Cluster-Measures-1">Cluster Measures</a><a class="docs-heading-anchor-permalink" href="#Cluster-Measures-1" title="Permalink"></a></h2><p>We can restrict this analysis to single clusters as well.</p><p>With the methods <a href="@ref">&#39;cluster<em>measure</em>mean&#39;</a> and <a href="@ref">&#39;cluster<em>measure</em>std&#39;</a> get the means and stds of selected measures seperatly for each cluster. We can plot these with an errorbar plot to get an intuition into typical values of these measures for each cluster and how they differ from each other.</p><pre><code class="language-julia">colororder = [&quot;blue&quot;,&quot;orange&quot;,&quot;green&quot;,&quot;red&quot;,&quot;purple&quot;,&quot;brown&quot;,&quot;magenta&quot;,&quot;olive&quot;,&quot;cyan&quot;]
measure_1 = 1
measure_2 = 2

m1m = cluster_measure_mean(kosol, db_res, measure_1)
m1sd = cluster_measure_std(kosol, db_res, measure_1)
m2m = cluster_measure_mean(kosol, db_res, measure_2)
m2sd = cluster_measure_std(kosol, db_res, measure_2)

SC = PyPlot.scatter(m1m, m2m, c=colororder[1:length(m1m)])
PyPlot.errorbar(m1m, m2m, fmt=&quot;o&quot;, ms=0,ecolor=colororder, xerr=0.005*m1sd, yerr=0.1*m2sd)
PyPlot.xlabel(&quot;Average Mean&quot;)
PyPlot.ylabel(&quot;Average Std&quot;)
PyPlot.savefig(&quot;output_msk.png&quot;)</code></pre><p><img src="../img/output_msk.png" alt="Cluster Means and Stds"/></p><p>In this case we scaled the error bars, as the Stds of the measures is much larger than the differences in the Average meausres. This is due to the fact that the Kuramoto oscillators are all oscillating relativly fast in this setup. It is important to note that for Cluster 3, the synchronous state, the Stds have a very small Std, meaning that almost all trials in this cluster have the same Std. This is clearly a strong indicator for a synchronous state. Cluster 2 and the noise cluster have only a slightly different average mean and std, if one would decrease the DBSCAN <code>\epsilon</code> parameter, they would probably be classified as only one cluster.</p><p>The method <a href="../ref/clustering_funcs/#MCBB.cluster_measures"><code>cluster_measures</code></a> gets the measure for each cluster seperately and applies a sliding window. The routine returns the parameter values of the sliding window, a <span>$N_{cluster}\times N_{measures}\times N_{dim}\times N_{windows}$</span> array for measures that are evalauted for every dimension and a <span>$N_{cluster}\times N_{measures}\times N_{windows}$</span> for global measures. For windows in which the cluster has no members a <code>NaN</code> is returned. This is (in constrast to <code>missing</code> or <code>nothing</code>) compatible with most plotting routines. We should however always define common x-Limits for the plots because of this. It returns these within a <a href="../ref/clustering_funcs/#MCBB.ClusterMeasureResult"><code>ClusterMeasureResult</code></a> struct that can be plotted easily, as they are plot recipes defined.</p><pre><code class="language-julia">cluster_meas_res = cluster_measures(ko_mcp, kosol, db_res, 0.1, 0.01);</code></pre><pre><code class="language-julia">xlim_values = [0, 5]
plot(cluster_meas_res, 1, 1, xlims=xlim_values, title=&quot;Means Cluster 1&quot;, xlabel=&quot;Coupling K&quot;)</code></pre><p><img src="../img/output_12_0.png" alt="Kuramoto Cluster 1 Means"/></p><pre><code class="language-julia">plot(cluster_meas_res, 1, 2, xlims=xlim_values, title=&quot;Means Cluster 2&quot;, xlabel=&quot;Coupling K&quot;)</code></pre><p><img src="../img/output_13_0.png" alt="Kuramoto Cluster 2 Means"/></p><pre><code class="language-julia">plot(cluster_meas_res, 1, 3, xlims=xlim_values, title=&quot;Means Cluster 3&quot;, xlabel=&quot;Coupling K&quot;)</code></pre><p><img src="../img/output_14_0.png" alt="Kuramoto Cluster 3 Means"/></p><p>The method <a href="../ref/clustering_funcs/#MCBB.cluster_means-Tuple{myMCSol,DbscanResult}"><code>cluster_means</code></a> returns the mean value of each measure for each cluster.</p><pre><code class="language-julia">cluster_ms = cluster_means(kosol, db_res);
print(&quot;Means of the 3rd cluster: &quot;)
print(cluster_ms[3,1,:])</code></pre><pre><code class="language-none">Means of the 3rd cluster: [29.4609, 29.4524, 29.4574, 29.4589, 29.4585, 29.4609, 29.4593, 29.4607, 31.5164, 29.4558, 27.5155, 29.4559, 29.4578, 29.4578, 29.4576, 29.4582, 31.7665, 29.4609, 29.4653, 29.595]</code></pre><h2 id="Single-Trajectories-1"><a class="docs-heading-anchor" href="#Single-Trajectories-1">Single Trajectories</a><a class="docs-heading-anchor-permalink" href="#Single-Trajectories-1" title="Permalink"></a></h2><p>With the method <a href="../ref/clustering_funcs/#MCBB.get_trajectory"><code>get_trajectory</code></a> we can get the full trajectory of an example trial within a certain cluster. This can help us get a further impression of the nature of the trajectories inside the cluster.</p><pre><code class="language-julia">IM = PyPlot.imshow(Matrix(get_trajectory(ko_mcp,kosol, db_res, 3,only_sol=true)), aspect=4)
PyPlot.ylabel(&quot;Oscillator i&quot;)
PyPlot.xlabel(&quot;Time&quot;)
cb = PyPlot.colorbar(IM, orientation=&quot;horizontal&quot;)
cb[:ax][:set_xlabel](&quot;Colorbar: Im(z)&quot;, rotation=0)</code></pre><p>For the zeroth/Noise cluster we see an unordered system</p><p><img src="../img/kura_unordered.png" alt="Kuramoto Unordered Example"/></p><p>and for the second cluster we see a synchronized system (except for one oscillator that is disconnected in this particular random network)</p><p><img src="../img/kura_ordered.png" alt="Kuramoto Ordered Example"/></p><h2 id="Cluster-Measure-Histograms-1"><a class="docs-heading-anchor" href="#Cluster-Measure-Histograms-1">Cluster Measure Histograms</a><a class="docs-heading-anchor-permalink" href="#Cluster-Measure-Histograms-1" title="Permalink"></a></h2><p>It is also possible to show how the histograms of a measure on a sliding window. <a href="../ref/clustering_funcs/#MCBB.cluster_measures_sliding_histograms"><code>cluster_measures_sliding_histograms</code></a> does just that. It returns for each cluster and for each window a histogram of a measure of your choice as a <a href="../ref/clustering_funcs/#MCBB.ClusterMeasureHistogramResult"><code>ClusterMeasureHistogramResult</code></a>.</p><pre><code class="language-julia">cluster_hist_res = cluster_measures_sliding_histograms(ko_mcp, kosol, db_res, 1, 0.25, 0.125)
plot(cluster_hist_res, 1)</code></pre><p><img src="../img/kura_hists_cluster1.png" alt="Kuramoto Cluster 1"/></p><p>For the synchronized state the means are in a narrow band and outside of these band they are no values, while for the unordered cluster the means have a broad distribution.</p><p><img src="../img/kura_hists_cluster2.png" alt="Kuramoto Cluster 2"/></p><h2 id="Cluster-Initial-Conditions-1"><a class="docs-heading-anchor" href="#Cluster-Initial-Conditions-1">Cluster Initial Conditions</a><a class="docs-heading-anchor-permalink" href="#Cluster-Initial-Conditions-1" title="Permalink"></a></h2><p><a href="../ref/clustering_funcs/#MCBB.ClusterICSpaces"><code>ClusterICSpaces</code></a> enables us to analyse which initial conditions lead to the different clusters. The <span>$struct$</span> is constructed with <a href="../ref/clustering_funcs/#MCBB.ClusterICSpaces"><code>ClusterICSpaces</code></a>. Additional parameter bounds can be provided to rescrict the analysis to the specified parameter range. It returns the <a href="../ref/clustering_funcs/#MCBB.ClusterICSpaces"><code>ClusterICSpaces</code></a>-struct with the fields:</p><ul><li><code>data::AbstractArray</code>: N<em>cluster long Array of N</em>dim+1 (+1 for the parameter) Arrays with the ICs/Parameter, e.g. <code>data[2][1]</code> for the ICs of IC-dimension 1 that lead to results classified in cluster 2</li><li><code>histograms::AbstractArray</code>: N<em>cluster long array of of N</em>dim+1 histograms for each IC/Par dimension and Cluster</li><li><code>means::AbstractArray</code>: means of data</li><li><code>stds::AbstractArray</code>: stds of data</li></ul><p>Statistics of the ICs across their dimension. For each run the mean, stds, skew of the ICs used for this run is calculated, These are the distributions of theses statistics for all runs. For example certain clusters/behaviour must be favoured if the ICs are already very close together, thus possessing a small <span>$std$</span></p><ul><li><code>cross_dim_means::AbstractArray</code></li><li><code>cross_dim_stds::AbstractArray</code></li><li><code>cross_dim_skews::AbstractArray</code></li></ul><pre><code class="language-julia">cics = ClusterICSpaces(ko_mcp, kosol, db_res; min_par=1, max_par=4);</code></pre><pre><code class="language-julia">PyPlot.plt[:hist](cics.cross_dim_stds[1], density=true, alpha=0.5, label=&quot;Cluster1&quot;)
PyPlot.plt[:hist](cics.cross_dim_stds[2], density=true, alpha=0.5, label=&quot;Cluster2&quot;)
PyPlot.plt[:hist](cics.cross_dim_stds[3], density=true, alpha=0.5, label=&quot;Cluster3&quot;)
PyPlot.xlabel(&quot;Standard Deviation of all ICs in a run&quot;)
PyPlot.ylabel(&quot;rel. Magnitude&quot;)
PyPlot.legend();</code></pre><p><img src="../img/output_19_0.png" alt="Kuramoto Cross Dim IC"/></p><p>This shows the Stds of the ICs for each Cluster.</p><p>Next we plot the distributions of each IC dimension for each Cluster.</p><pre><code class="language-julia">ICPlot = 1:6 # which IC dimensions to plot
cics_in = cics
i_cluster = 1 # which cluster to plot

hists = cics_in.histograms[i_cluster]
nbins = length(hists[1].weights)
n_dim = length(ICPlot)
weights = zeros((n_dim,nbins))
edges = zeros((n_dim,nbins+1))
for i=1:n_dim
    weights[i,:] = hists[ICPlot[i]].weights
    edges[i,:] = hists[ICPlot[i]].edges[1]
end

weight_maxima = maximum(weights;dims=2)
hist_range = [minimum(edges),maximum(edges)]
max_weight_maxima = maximum(weight_maxima)
x_locs = 0:(max_weight_maxima+0.05*max_weight_maxima):(sum(weight_maxima)+max_weight_maxima)

centers = (edges[:,1:end-1] .+ edges[:,2:end]) ./ 2
heights = diff(edges, dims=2)

fig, ax = PyPlot.subplots()


for i_hist=1:n_dim
    ax[:barh](centers[i_hist,:], weights[i_hist,:], height=heights[i_hist,:], left=x_locs[i_hist])
end

PyPlot.xlabel(&quot;IC Dimensions&quot;)
PyPlot.ylabel(&quot;IC values&quot;)

ax[:set_xticks](x_locs)
ax[:set_xticklabels]([string(i) for i in ICPlot]);</code></pre><p><img src="../img/output_21_0.png" alt="Kuramoto Histograms"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basic_usage/">« Basic Usage</a><a class="docs-footer-nextpage" href="../hpc/">Running it on a HPC »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 11 October 2020 19:52">Sunday 11 October 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
